let chai = require('chai');
let DomHandler = require('domhandler');

require('../../src/env/overrides.js');

chai.should();

// Collection of test functions for reuse throughout the Smagger testing classes.
export class TestAid {

	// Handy helper to create a callback function that will fail a test with the given message.
	//
	// <message> failure message to output to test run.
	fail(message) {
		return () => chai.assert.fail(false, false, message);
	}

	// Creates a bare-bones 200-OK success header, mimicking that passed from the ios Environment.
	generateSuccessHeaders() {
		return { status: { code: 200 }};
	}

	// Tests for the existence of all available Actions (Comment, Delete, Like, and Share) within an actions array.
	//
	// <actions> array of Actions for testing.
	testAllActions(actions) {
		actions.length.should.equal(4);
		[ 'Comment', 'Delete', 'Like', 'Share' ].forEach((elem) => actions.filter((action) => action.type.toUpperCase() === elem.toUpperCase()).length.should.equal(1));
	}

	// Tests for the existence of only the default three Actions (Comment, Like, Share) within an actions array.
	//
	// <actions> array of Actions for testing.
	testBasicActions(actions) {
		actions.length.should.equal(3);
		[ 'Comment', 'Like', 'Share' ].forEach((elem) => actions.filter((action) => action.type.toUpperCase() === elem.toUpperCase()).length.should.equal(1));
	}

	// Tests for the existence of any two unique actions
	// <actions> array of Actions for testing.
    // <expectedActions> array of Actions type names that are allowed.
	testTwoActions(actions, expectedActions) {
		actions.length.should.equal(2);
        actions.forEach((action) => expectedActions.filter((entry) => entry.toUpperCase() === action.type.toUpperCase()).length.should.equal(1) );
	}

	// Tests for the existence of a single Action within the given actions array.
	//
	// <actions> array to examine for the Action entry.
	// <action> the Action type constant that is expected to be the only element of the actions array.
	testSingleAction(actions, action) {
		actions.length.should.equal(1);
		actions[0].type.toUpperCase().should.equal(action.toUpperCase());
	}
	
	// Tests to ensure no Actions within the given actions array.
	//
	// <actions> array to examine for the Action entry.
	testNoActions(actions) {
	    actions.length.should.equal(0);
	}

	// Ensures the expected is a subset of the actual
	//
	// <expected>	Prepared object containing the test expected value.
	// <actual>		Value under test, generated by the functioning code.
	validate(expected, actual, isLog) {

		if (expected && !actual) {
			this.fail('No data object parsed and passed for testing.')();
		} else {

			if (Array.isArray(expected)) {
				chai.assert.equal(expected.length, actual.length);
			}

			for (var key in expected) {

				// Log validation (by default of no parameter, will not log)
				if (isLog) {
					logger.debug('Validate ' + key + ' (' + expected[key] + ' = ' + actual[key] + ')')
				}

				chai.assert.isTrue(actual.hasOwnProperty(key));
				chai.assert.equal(typeof(expected[key]), typeof(actual[key]));

				if (typeof(expected[key]) === 'string' || typeof(expected[key]) === 'boolean' || typeof(expected[key]) === 'number') {
					actual[key].should.equal(expected[key]);
				} else {
					this.validate(expected[key], actual[key], isLog);
				}
			}
		}
	}
	
}

// Handy class to configure a set of DomHandlers.
export class DummyHandlerFactory {
	// Prepares this factory to return one or more DomHandlers that will pass the given result to the utilising Html Parser.
	// This constructor clones the results array, allowing reuse of data sources in tests.
	//
	// <result> single object or array of object results to pass. If this is an array, each result will be used in turn.
	constructor(result) {
		if (Array.isArray(result)) {
			result = result.slice(0);
		}
		this.result = result;
	}

	create(host, path, descriptor, callback) {
		return new DomHandler((error, data) => {
			if (Array.isArray(this.result)) {
				callback(error, this.result.shift());
			} else {
				callback(error, this.result);
			}
		});
	}
}

// Dummy UserRegistry for mocking.
export class DummyUserRegistry {
	// Prepares this registry to return one or more Users.
	// This constructor clones the results array, allowing reuse of data sources in tests.
	//
	// <result> single object or array of object results to pass. If this is an array, each result will be used in turn.
  // <isLog> indicates if to log profile request against returned user
	constructor(result, isLog) {
		if (Array.isArray(result)) {
			result = result.slice(0);
		}
		this.result = result;
		this.isLog = isLog
	}
	
	doRequestUser(path, callback, isCacheOnly) {
		let doCallback = (user) => {
			if (isCacheOnly && !user) {
				if (this.isLog) {
					logger.debug('UserRegistry: no callback for cached path ' + path)
				}
			} else {
				if (this.isLog) {
					logger.debug('UserRegistry: path ' + path + ' callback with user ' + JSON.stringify(user))
				}
				callback(user)
			}
		}
		if (Array.isArray(this.result)) {
			doCallback(this.result.shift())
		} else {
			doCallback(this.result);
		}
	}

	requestUser(path, callback) {
		this.doRequestUser(path, callback, false)
	}
	
	requestCachedUser(path, callback) {
		this.doRequestUser(path, callback, true)
	}
}
